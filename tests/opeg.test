package require tcltest
::tcltest::configure {*}$argv

package require djdsl::opeg



namespace eval ::djdsl::opeg::test {
  namespace import ::tcltest::*
  namespace import ::djdsl::opeg::*
  # namespace import ::djdsl::lm::*
  
  variable SETUP {
    
  }

  
  variable CLEANUP {
    if {[array exists {}]} {
      foreach k [array names {}] {
        set v [set ($k)]
        foreach i $v {
          if {[::nsf::is object $i]} {
            $i destroy
          }
        }
      }
      array unset {}
      unset -nocomplain k
      unset -nocomplain v
    }
    foreach g [Grammar info instances -closure] {
      if {[::nsf::is object $g]} {
        $g destroy
      }
    }
    unset -nocomplain g
  }

  test opeg-0.1 "PG, loading from rules" -setup $SETUP -body {
    set (eLangGrm) [Grammar new -name ELang -start STAT {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- <digit>+;
      ID   <- <alpha>+;
void: WS   <- <space>+;
    }]

    lappend () [$(eLangGrm) info has type ::djdsl::opeg::Grammar]

    set (eLangParser) [$(eLangGrm) new]

    lappend () [$(eLangParser) info has type ::pt::rde::nx]

  } -cleanup $CLEANUP -result "1 1"

  
  test opeg-0.2 "PG inclusion" -setup $SETUP -body {
    set (eLangGrm) [Grammar new -name ELang -start STAT {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      ID   <- <alpha>+;
void: WS   <- <space>+;
      X    <- Y;
      Y    <- Z;      
    }]
    
    lappend () [$(eLangGrm) info has type ::djdsl::opeg::Grammar]

    lappend () [lsort [$(eLangGrm) rules nts]]

    # A second (including, receiving) PG

    set (myELang) [Grammar create MyELang -start STAT -merges $(eLangGrm) {
      EXPR <- INT / ID;
      INT  <- <digit>+;
    }]

    lappend () [$(myELang) info has type ::djdsl::opeg::Grammar]

    lappend () [lsort [$(myELang) rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    lappend () [lsort [[$(myELang) resulting] rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input EXPR" {s e args} {
        incr :counter
        return
      }
    }]]] parse {1;a;}

    lappend () [$(mf) eval {set :counter}]
 
    
  } -cleanup $CLEANUP -result [list 1 {EXPR ID STAT WS X Y} 1 {EXPR INT} \
                                   {EXPR ID INT STAT} {EXPR ID INT STAT} \
                                   2]

  test opeg-0.3 "Useless removal: Wrong order" -setup $SETUP -body {

    # Example taken from http://kilby.stanford.edu/~rvg/154/handouts/useless.html
    
    set (myLangGrm) [Grammar new -start S -name MyLang {
      S <- A B / 'a';
      A <- 'a' A;
      B <- 'b';
    }]

    set container [::djdsl::opeg::Grammar::Container new -grammar $(myLangGrm)]

    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op drop unreachable $container
    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op drop unrealizable $container
    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op flatten $container
    lappend () [$(myLangGrm) rules get]
    
    
  } -cleanup $CLEANUP -result [list {A B S} \
                                   {A B S} \
                                   {B S} \
                                   {B {t b} S {t a}}]

  test opeg-0.4 "Useless removal: Correct order" -setup $SETUP -body {

    package req pt::peg::op    
    
    set (myLangGrm) [Grammar new -start S -name MyLang {
      S <- A B / 'a';
      A <- 'a' A;
      B <- 'b';
    }]

    set container [::djdsl::opeg::Grammar::Container new -grammar $(myLangGrm)]

    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op drop unrealizable $container
    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op drop unreachable $container
    lappend () [$(myLangGrm) rules nts]

    ::pt::peg::op flatten $container
    lappend () [$(myLangGrm) rules get]
    
    
  } -cleanup $CLEANUP -result [list {A B S} \
                                   {B S} \
                                   {S} \
                                   {S {t a}}]
  
  test opeg-0.5 "Qualify rules" -setup $SETUP -body {
    
    set (myLangGrm) [Grammar new -start S -name MyLang {
      S <- A B / 'a';
      A <- 'a' A;
      B <- 'b';
    }]

    lappend () [$(myLangGrm) rules nts]
    
    lappend () [dict keys [$(myLangGrm) qualify [$(myLangGrm) rules get]]]

    # puts >>>[dict values [$(myLangGrm) qualify [$(myLangGrm) rules get]]]
    
  } -cleanup $CLEANUP -result [list {A B S} {MyLang::A MyLang::B MyLang::S}]

  test opeg-0.6 "Define grammars + merge" -setup $SETUP -body {

    #// merge1 //
    # G0 (composed grammar)
    Grammar create ::G0 -start S

    G0 loadRules {
      S <- A B / 'a';
      A <- 'a' A;
      B <- 'b';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- ('a' / 'A') A / D;
      D <- 'd';
    }

    # G1' (resulting grammar)
    G1 resulting rules nts
    #// end //
        
  } -cleanup $CLEANUP -result "A D"

  test opeg-0.7 "Define grammars + merge + transforms" -setup $SETUP -body {

    # G0 (composed grammar)
    Grammar create ::G0 -start S

    G0 loadRules {
      S <- A B / 'a';
      A <- 'a' A;
      B <- 'b';
    }

    #// merge2 //
    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- ('a' / 'A') A / D;
      D <- 'd';
    } {
      # transformations
      G0::B ==> ; # rule deletion
    }
    #// end //

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    G1 loadTransforms {
      # transformations, reloaded
      D ==> ; # rule deletion
    }

    # G1' (resulting grammar), reloaded
    lappend () [G1 resulting rules nts]

    G1 loadTransforms {
      # transformations, reloaded
      G0::S ==> ; # rule deletion
    }

    # G1' (resulting grammar), reloaded
    lappend () [G1 resulting rules nts]

    #// merge3 //
    G1 loadTransforms {
      # transformations, reloaded
      G0::B ==> ; # rule deletion
    }
    #// end //

    # G1' (resulting grammar), reloaded
    lappend () [G1 resulting rules nts]

        
  } -cleanup $CLEANUP -result [list {G1::A G1::D} {} {G1::A G1::D} {G1::A G1::D}]

  # Rules command/query interface

  test opeg-1.1 "Rule(s): rename" -setup $SETUP -body {
    set (eLangGrm) [Grammar new -name ELang -start STAT {
      STAT <- (EXPR ';')+ ;
      EXPR <- INT;
      INT   <- <digit>+;
    }]
    
    lappend () [$(eLangGrm) rules nts]
    
    $(eLangGrm) rules rename INT TIN
    
    lappend () [$(eLangGrm) rules nts]

    # TIN rule is inaccessible, EXPR can't recognize a terminal; AND:
    # STAT can't recognize a terminal structure without EXPR being
    # useful, so all become dropped!
    
    lappend () [[$(eLangGrm) resulting] rules nts];

    [$(eLangGrm) resulting] clean

    lappend () [[$(eLangGrm) resulting] rules nts];
    
  } -cleanup $CLEANUP -result [list {EXPR INT STAT} {EXPR STAT TIN} {} {}] 



  test opeg-1.2 "Rule(s): rename for restriction" -setup $SETUP -body {

    set (eLangGrm) [Grammar new -name ELang -start STAT {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      ID   <- WS* <alpha>+ WS*;
void: WS   <- <space>;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]

    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm) {
      EXPR <- INT / ID;
      INT  <- <digit>+;
    }]
    

    lappend () [lsort [$(myELang) rules nts]]

    [$(myELang) resulting] rules rename WS _

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean

    lappend () [lsort [$(myELang) resulting rules nts]]
    
    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input EXPR" {s e args} {
        incr :counter
        return
      }
    }]]] parse {1;a;}

    lappend () [$(mf) eval {set :counter;}]
    
  } -cleanup $CLEANUP -result [list {EXPR ID STAT WS} {EXPR INT} {EXPR ID INT STAT _} {EXPR ID INT STAT} 2]

  test opeg-1.3 "Rule(s): extract w/o rewrite" -setup $SETUP -body {

    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- WS* <digit>+ WS*;
void: WS   <- <space>;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]

    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
    } {
      # Transformations applied on resulting definition
      INT <== ELang::INT; # extract w/o rewrite
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang EXPR" {s e args} {
        incr :counter
        return
      }
    }]]] parse {1;2;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list {INT WS} {EXPR STAT} {ELang::WS MyELang::EXPR MyELang::INT MyELang::STAT} \
                                   {ELang::WS MyELang::EXPR MyELang::INT MyELang::STAT} 2]

  test opeg-1.4 "Rule(s): incremental extract w/o rewrite" -setup $SETUP -body {

    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- WS* <digit>+ WS*;
void: WS   <- <space>;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]

    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- OCTAL+ ;
      OCTAL <- '0' [1-7] [0-7] <digit>?;
    } {
      # Transformations applied on resulting definition
      INT <== ELang::INT; # extract w/o rewrite (add as last alternate)
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang OCTAL" {s e args} {
        incr :counter
        return
      }
    }]]] parse { 1 ;0377;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list {INT WS} {EXPR INT OCTAL STAT} \
                                   {ELang::WS MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {ELang::WS MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} 1]

  test opeg-1.5 "Rule(s): extract with rewrite (<=>)" -setup $SETUP -body {

    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- WS* <digit>+ WS*;
void: WS   <- <space>;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]

    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
    } {
      # Transformations applied on resulting definition
      INT <=> ELang::INT ; # extract plus rewrite
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang EXPR" {s e args} {
        incr :counter
        return
      }
    }]]] parse {1;2;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list {INT WS} {EXPR STAT} {MyELang::EXPR MyELang::INT MyELang::STAT} \
                                   {MyELang::EXPR MyELang::INT MyELang::STAT} 2]

  
  test opeg-1.6 "Rule(s): incremental extract with rewrite (<=>)" -setup $SETUP -body {
    
    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- D+;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]
    
    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- OCTAL+ ;
      D    <- <digit>;
      OCTAL <- '0' [1-7] [0-7] <digit>?;
    } {
      # Transformations applied on resulting definition
      INT <=> ELang::INT end; # extract plus rewrite (add as last alternate)
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang OCTAL" {s e args} {
        dict incr :counter octal
        return
      }
      :public object method "input MyELang INT" {s e args} {
        dict incr :counter int
        return
      }
    }]]] parse {0377;1;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list INT {D EXPR INT OCTAL STAT} \
                                   {MyELang::D MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {MyELang::D MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {octal 1 int 2}]

   test opeg-1.7 "Rule(s): delete (==>)" -setup $SETUP -body {
    
    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- D+;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]
    
    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -merges $(eLangGrm)  {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- OCTAL+ / D+ ;
      D    <- <digit>;
      OCTAL <- '0' [1-7] [0-7] <digit>?;
    } {
      # Transformations applied on resulting definition
      D ==>; # remove rule with NT D
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang OCTAL" {s e args} {
        dict incr :counter octal
        return
      }
      :public object method "input MyELang INT" {s e args} {
        dict incr :counter int
        return
      }
    }]]] parse {0377;017;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list INT {D EXPR INT OCTAL STAT} \
                                   {MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {octal 2 int 2}]

  test opeg-1.8 "Rule(s): positional delete (==>)" -setup $SETUP -body {
    
    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- D+;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]
    
    # A second (including, receiving) PG
    
    set (myELang) [Grammar new  -name MyELang -start STAT -merges $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- OCTAL+ / D+ ;
      D    <- <digit>;
      OCTAL <- '0' [1-7] [0-7] <digit>?;
    } {
      # Transformations applied on resulting definition
      {INT end} ==>; # remove last alternate of rule for NT INT.
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang OCTAL" {s e args} {
        dict incr :counter octal
        return
      }
      :public object method "input MyELang INT" {s e args} {
        dict incr :counter int
        return
      }
    }]]] parse {0377;017;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list INT {D EXPR INT OCTAL STAT} \
                                   {MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {octal 2 int 2}]

  test opeg-1.9 "Rule(s): extract with cascade/rewrite (<*>)" -setup $SETUP -body {
    
    set (eLangGrm) [Grammar new -name ELang -start INT {
      INT  <- D+;
      D    <- <digit>;
    }]
    
    lappend () [lsort [$(eLangGrm) rules nts]]
    
    # A second (including, receiving) PG
    
    set (myELang) [Grammar new -name MyELang -start STAT -superclasses $(eLangGrm) {
      STAT <- (EXPR ';')+;
      EXPR <- INT;
      INT  <- OCTAL+ ;
      OCTAL <- '0' [1-7] [0-7] <digit>?;
    } {
      # Transformations applied on resulting definition
      INT <*> ELang::INT; # extract plus rewrite (add as last alternate)
    }]

    lappend () [lsort [$(myELang) rules nts]]

    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) resulting] clean
    
    lappend () [lsort [$(myELang) resulting rules nts]]

    [$(myELang) new -factory [set (mf) [ModelFactory new {
      :public object method "input MyELang OCTAL" {s e args} {
        dict incr :counter octal
        return
      }
      :public object method "input MyELang INT" {s e args} {
        dict incr :counter int
        return
      }
    }]]] parse {0377;1;}
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list {D INT} {EXPR INT OCTAL STAT} \
                                   {MyELang::D MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {MyELang::D MyELang::EXPR MyELang::INT MyELang::OCTAL MyELang::STAT} \
                                   {octal 1 int 2}]

  test opeg-1.10 "extract w/o rewrite (existing)" -setup $SETUP -body {
     
    # G0 (composed grammar)
    Grammar create ::G0 -start A

    G0 loadRules {
      A <- B+;
      B <- 'b';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- B+;
      B <- 'B';
    } {
      A <== G0::A
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    set (p) [[G1 resulting] new -factory [set (mf) [ModelFactory new {
      :public object method "input G0 B" {s e args} {
        dict incr :counter b
        return
      }
      :public object method "input G1 B" {s e args} {
        dict incr :counter B
        return
      }
    }]]]
    
    $(p) parse "bbb"

    lappend () [$(mf) eval {set :counter}]

    $(p) parse "BBB"
    
    lappend () [$(mf) eval {set :counter}]
    
  } -cleanup $CLEANUP -result [list {G0::B G1::A G1::B} {b 3} {b 3 B 3}]


  test opeg-2.1 "Define object grammars + merge" -setup $SETUP -body {

    # G0 (composed grammar)
    Grammar create ::G0 -start S

    G0 loadRules {
      S <- `ABClass` a:A b:B / 'a';
      A <- 'a' A;
      B <- 'b';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- ('a' / 'A') A / `DClass` d:D;
      D <- 'd';
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    # puts [G1 resulting rules get]

    set (helper) [nx::Class create ::DClass {
      :property d
    }]
    
    set (p) [[G1 resulting] new]
    lappend () [[$(p) parse d] info class]
        
  } -cleanup $CLEANUP -result [list "A _FIELD_0_d D" ::DClass]

  test opeg-2.2 "Define object grammars + merge" -setup $SETUP -body {
     
    # G0 (composed grammar)
    Grammar create ::G0 -start S

    G0 loadRules {
      S <- 'x' / `ABClass` a:A b:B / `A` v:'a';
      A <- 'a' A;
      B <- 'b';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start S {
      A <- ('a' / 'A') A / `DClass` d:D;
      D <- 'd';
    } {
      S <== G0::S
      G0::A ==>
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    # puts [G1 resulting rules get]

    set (helper) [nx::Class create ::A {
      :property v
    }]
    
    set (p) [[G1 resulting] new]
    set (a) [$(p) parse a]
    lappend () [$(a) info class]
    lappend () [$(a) cget -v]
        
  } -cleanup $CLEANUP -result [list {G0::_FIELD_0_v G1::S} ::A "a"]

  test opeg-2.3 "Define object grammars + merge + queries" -setup $SETUP -body {
     
    # G0 (composed grammar)
    Grammar create ::G0 -start S

    G0 loadRules {
      S <- `A` v:(`$root 1st $0` B / `$root 2nd $0` C) / `ABClass` a:A b:B;
      A <- 'a' A;
      B <- 'b';
      C <- 'c';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start S {
      A <- ('a' / 'A') A / `DClass` d:D;
      D <- 'd';
    } {
      S <== G0::S
      G0::A ==>
      G0::C ==>
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    # puts [G1 resulting rules get]

    set (helper) [nx::Class create ::A {
      :property v
      :public forward 1st %self shout %method
      :public forward 2nd %self shout %method
      :public method shout {args} {
        return $args
      }
    }]
    
    set (p) [[G1 resulting] new]
    set (a) [$(p) parse b]
    lappend () [$(a) info class]
    lappend () [$(a) cget -v]

    G1 loadTransforms {
      S <== G0::S
      G0::A ==>
    }

    set (p2) [[G1 resulting] new]
    set (c)  [$(p2) parse c]
    lappend () [$(c) info class]
    lappend () [$(c) cget -v]
        
  } -cleanup $CLEANUP -result [list {G0::B G0::_FIELD_0_v G1::S} ::A "1st get b" ::A "2nd get c"]

  
  test opeg-2.4 "Define object grammars + merge + append" -setup $SETUP -body {
     
    # G0 (composed grammar)
    Grammar create ::G0 -start A

    G0 loadRules {
      A <- `AClass` v:'a';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- ('a' / 'A') A / `DClass` v:D;
      D <- 'd';
    } {
      A <== G0::A 0
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    set (helper) [nx::Class create ::AClass {
      :property v
      :public forward 1st %self shout %method
      :public forward 2nd %self shout %method
      :public method shout {args} {
        return $args
      }
    }]

    set (helper2) [nx::Class create ::DClass -superclasses AClass]
    
    set (p) [[G1 resulting] new]
    set (a) [$(p) parse "d"]
    lappend () [$(a) info class]
    lappend () [$(a) cget -v]
    set (a2) [$(p) parse "a"]
    lappend () [$(a2) info class]
    lappend () [$(a2) cget -v]
        
  } -cleanup $CLEANUP -result [list {G0::_FIELD_0_v G1::A G1::D G1::_FIELD_0_v} "::DClass" "d" "::AClass" "a"]

  test opeg-2.5 "Define object grammars + merge + append" -setup $SETUP -body {
     
    # G0 (composed grammar)
    Grammar create ::G0 -start A

    G0 loadRules {
      A <- `AClass` v:'a';
    }

    # G1 (receiving grammar)
    Grammar create ::G1 -merges G0 -start A {
      A <- ('a' / 'A') A / `DClass` v:D;
      D <- 'd';
    } {
      A <== G0::A 0
      {G1::A end} ==>
    }

    # G1' (resulting grammar)
    lappend () [G1 resulting rules nts]

    set (helper) [nx::Class create ::AClass {
      :property v
    }]

    set (helper2) [nx::Class create ::DClass -superclasses AClass]
    
    set (p) [[G1 resulting] new]
    set (a2) [$(p) parse "a"]
    lappend () [$(a2) info class]
    lappend () [$(a2) cget -v]
    
  } -cleanup $CLEANUP -result [list {G0::_FIELD_0_v G1::A} ::AClass a]


  test opeg-3.1 "Special-value propagation (parser <-> factory): quoted string" -setup $SETUP -body {

    nx::Class create C {
      :property p1
    }

    set (g) [Grammar newFromScript {
      OPEG MyPEG (D)
         D <- `C` p1:E;
 leaf:   E <- '\"' <alnum>+ '\"';
      END;
    }]
    
    set (p) [$(g) new]
    
    set (out) [$(p) parse {"abc"}]
    
    lappend () [expr {[$(out) info class] eq [C]}]
    lappend () [$(out) cget -p1]
    
  } -cleanup $CLEANUP -result [list 1 \"abc\"]
  
  test opeg-3.2 "Special-value propagation (parser <-> factory): invalid list" -setup $SETUP -body {
    
    set (helper) [nx::Class create C {
      :property p1
    }]
    
    set (g) [Grammar newFromScript "
      OPEG MyPEG (D)
                D <- `C` p1:E (<space>+ E)+;
      leaf:  	E <- '\"' (<alnum> / '\{' / '\}')+ '\"';
      END;
    "]
    
    set (p) [$(g) new]
  
    
    set x "\{\}c"
    
    lappend () [string is list $x]
    
    set (out) [$(p) parse "\"$x\" \"{}xz\""]
    
    lappend () [expr {[$(out) info class] eq $(helper)}]
    lappend () [expr {[$(out) cget -p1] eq "\"$x\""}]
    lappend () [string is list [lindex [$(out) cget -p1] 0]]
    
  } -cleanup $CLEANUP -result [list 0 1 1 0]

  test opeg-4.1 "Collections" -setup $SETUP -body {
    
    set (helper) [nx::Class create HyperPoint {
      :property x:integer,1..*
      :property y:integer
    }]
    
    set (g) [Grammar newFromScript "
      OPEG Coordinate (P)
      	P  <- `HyperPoint` '(' (x:<digit>)+ ',' (x:<digit> y:<digit>)? ')';
      END;
    "]
    
    set (p) [$(g) new]
  
    set (out) [$(p) parse "(92,32)"]
    
    lappend () [expr {[$(out) info class] eq $(helper)}]
    lappend () [expr {[$(out) cget -x] eq "9 2 3"}];
    lappend () [expr {[$(out) cget -y] eq "2"}];
    
  } -cleanup $CLEANUP -result [list 1 1 1]

  test opeg-4.2 "Collections" -setup $SETUP -body {
    
    set (helper) [nx::Class create Call {
      :property fun
      :property args
    }]
    
    set (g) [Grammar newFromScript "
        OPEG CallDecl (C)
             C    <- `Call` fun:ID '(' (args:Exp)? (',' args:Exp)* ')';
             ID   <- 'foo';
             Exp  <- <digit>;
        END;
    "]
    
    set (p) [$(g) new]


    set (out1) [$(p) parse {foo(1,1,2,2)}]

    lappend () [expr {[$(out1) info class] eq $(helper)}]
    lappend () [expr {[$(out1) cget -fun] eq "foo"}];
    lappend () [expr {"args" in [$(out1) info vars]}];
    lappend () [expr {[$(out1) cget -args] eq "1 1 2 2"}];


    set (out2) [$(p) parse {foo()}]    
    lappend () [expr {[$(out2) info class] eq $(helper)}]
    lappend () [expr {[$(out2) cget -fun] eq "foo"}];
    lappend () [expr {"args" ni [$(out2) info vars]}];
    
  } -cleanup $CLEANUP -result [list 1 1 1 1 1 1 1]

  test opeg-4.3 "Collections" -setup $SETUP -body {
    
    set (helper) [nx::Class create Call {
      :property fun
      :property args
    }]
    
    set (g) [Grammar newFromScript "
        OPEG CallDecl (C)
             C    <- `Call` fun:ID '(' ARGS ')';
             ARGS <- (args:Exp)? (',' ARGS)*;
             ID   <- 'foo';
             Exp  <- <digit>;
        END;
    "]
    
    set (p) [$(g) new]

    set (out) [$(p) parse {foo(1,1,2,2)}]

    lappend () [expr {[$(out) info class] eq $(helper)}]
    lappend () [expr {[$(out) cget -fun] eq "foo"}];
    lappend () [expr {"args" in [$(out) info vars]}];
    lappend () [expr {[$(out) cget -args] eq "1 1 2 2"}];
    
  } -cleanup $CLEANUP -result [list 1 1 1 1]

  test opeg-4.4 "Collections" -setup $SETUP -body {
    
    set (helper) [nx::Class create Call {
      :property fun
      :property args
    }]
    
    set (g) [Grammar newFromScript "
     OPEG CallDecl (C)
        C    <- `Call` fun:ID '(' ARGS ')';
        ARGS <- (args:Exp)? (',' args:Exp)*;
        ID   <- 'foo';
        Exp  <- <digit>;
      END;
    "]
    
    set (p) [$(g) new]

    set (out) [$(p) parse {foo(2,1,2,5)}]

    lappend () [expr {[$(out) info class] eq $(helper)}]
    lappend () [expr {[$(out) cget -fun] eq "foo"}];
    lappend () [expr {"args" in [$(out) info vars]}];
    lappend () [expr {[$(out) cget -args] eq "2 1 2 5"}];
    
  } -cleanup $CLEANUP -result [list 1 1 1 1]

  
}

# TODO: ... Why does [$container reachable] contain 'n'?
#       ... Can superfluous epsilons in sequences be eliminated? flattens? in:
#        ... {x epsilon {+ alpha} epsilon}
#       ... Issue: restriction via renaming vs. PG transformations?
#       When a rule gets renamed, its usefulness cannot be
#       determined anymore based on its RHS. This may change
#       transformations, whether relevant details are encoded at the caller's
#       site (calling RHS) or at the callee's side (called RHS).
#       ... RULE COMPOSITION: What about attributes (leaf, value, void) under combination?
#       ... check again whether ? and * should really be marked as realizable, widening or restricting?
#       ... get rid of epsilons in cleaned choices {is {/ {+ {n OCTAL}} epsilon}}
#       ... hide _FIELD_* NTs from introspective output?
#       ... modes under composition, in particular, the qualified ones.
#       ... opeg-2.4: when using <=> (rather than <==), should we rewrite field NTs
#           automatically for one level?
#       ... add validation spec vs. rules:
#           - cardinality of choice expressions and corresponding generators ...
#           - no definition with field declarations must be in mode 'leaf'.
#       ...   Check the invalid parses on ASGMT generator plus * :
#           if {0 && $start > $end} {
#             throw [list DJDSL OPEG INVALIDPARSE $start $end $ast] "Invalid parse detected."
#

return
if {0} {

    nx::Class create Machine {
    :property start:object,type=State
    :property states:object,type=State,1..*
  }
  
  nx::Class create State {
    :property machine:object,type=Machine; # / states
    :property name:alnum,required
    :property out:object,type=Transition,0..*
    :property in:object,type=Transition,0..*
  }
  
  nx::Class create Transition {
    :property event:alnum
    :property from:object,State; # / out
    :property to:object,State; # / in
  }
  


      set myELangBuilder [$(builderGen) bgen rules \
                            -name MyELang \
                            -start STAT \
                            -includes $(eLangBuilder) -transforms {
                              STAT <= ELang::STAT
                              STAT <=>
                              STAT +=
                              STAT =+>
                            } {
                              EXPR <- INT;
                              INT  <- <digit>+;
                              ID   <- <alpha>+;
                        void: WS   <- <space>+;
                            }]

    set (builder2) [${myELangBuilder} new]
    lappend () [$(builder2) info has type ::pt::rde::nx]

  
  ## NEXT STEPS

  ## 1) -> Check alternative syntaxes for ObjSpecs (not @, EBNF ideas, curly braces?)
  ## EBNF: special sequence (? ?)
  ## EBNF: () next to identifier?
  ## REGEX: named back-references notation (?=<name> ...)
  ## annotation-like: --> @IDENTIFIER
  ## FOR NOW: grave accent `...`
  
  ## 
  ## 2) -> Revise field notation to support built-in (PT, string is) ranges as well as non-terminal values for fields.
  ## DONE


## 3) -> Support for collections

set g3 {
OPEG Coordinate (P)
       P  <- `HyperPoint` '(' (x:<digit>)+ ',' (x:<digit> y:<digit>)? ')';
END;}

# puts stderr [string index $g3 41]
# $builderGen print $g3
set builderClass [$builderGen bgen $g3]
set coordBuilder [$builderClass new]


nx::Class create HyperPoint {
  :property x:integer,1..*
  :property y:integer
}

# $coordBuilder print {(92,32)}; #$coordBuilder print {(987,2)}
set p [$coordBuilder parse {(92,32)}]; #set p [$coordBuilder parse {(987,2)}]
? {$p info class} ::HyperPoint
? {$p cget -x} "9 2 3";
? {$p cget -y} "2";

# C ::= [Call] fun:id "(" args:Exp* @"," ")"

nx::Class create Call {
  :property fun
  :property args
}

set g4 {
OPEG CallDecl (C)
      C    <- `Call` fun:ID '(' (args:Exp)? (',' args:Exp)* ')';
      ID   <- 'foo';
      Exp  <- <digit>;
END;}

# $builderGen print $g4
set builderClass [$builderGen bgen $g4]
set callBuilder [$builderClass new]

set c [$callBuilder parse {foo(1,1,2,2)}];
? {$c info class} ::Call
? {$c cget -fun} "foo";
? {$c cget -args} "1 1 2 2";

set c [$callBuilder parse {foo()}];
? {$c info class} ::Call
? {$c cget -fun} "foo";
? {$c cget -args} {can't read "args": no such variable};

# TODO:
# ARGS <- (args:Exp)? (',' args:Exp)* a top-level list -> flatten!

set g5 {
OPEG CallDecl (C)
      C    <- `Call` fun:ID '(' ARGS ')';
      ARGS <- (args:Exp)? (',' args:Exp)*;
      ID   <- 'foo';
      Exp  <- <digit>;
END;}

# $builderGen print $g5
set builderClass [$builderGen bgen $g5]
set callBuilder [$builderClass new]

set c [$callBuilder parse {foo(1,1,2,2)}];
? {$c info class} ::Call
? {$c cget -fun} "foo";
? {$c cget -args} "1 1 2 2";

# ARGS <- args:Exp (','ARGS)* adds cascaded of lists

set g6 {
OPEG CallDecl (C)
      C    <- `Call` fun:ID '(' ARGS ')';
      ARGS <- (args:Exp)? (',' ARGS)*;
      ID   <- 'foo';
      Exp  <- <digit>;
END;}

# $builderGen print $g6
set builderClass [$builderGen bgen $g6]
set callBuilder [$builderClass new]

set c [$callBuilder parse {foo(2,1,2,5)}];
? {$c info class} ::Call
? {$c cget -fun} "foo";
? {$c cget -args} "2 1 2 5";

## 4) -> Enso examples

# start Drawing
# Drawing ::= [Drawing] "drawing" /> lines:Line* @/ /
# Line ::= [Line] "line" label:str /> points:Point2D* @/ < Adj? 
# Adj ::= / "adj" adj:<root.lines[it]>
# Point3D ::= [Point3D] "point" x:int y:int z:int
# Point2D ::= [Point2D] "point" x:int y:int

nx::Class create Drawing {
  :property lines:0..n,object,type=::Line
}

nx::Class create Line {
  :property label
  :property points:0..n,object,type=::Point2D
  # :property adj:object,type=::Line
  :property adj
}

nx::Class create Point2D {
  :property x:integer
  :property y:integer
}

set geom {
OPEG Drawing (Drawing)
      Drawing    <- `Drawing` 'drawing' (<space>+ lines:Line)+;
      Line       <- `Line` 'line' ' '+ DAPOSTROPH label:Str DAPOSTROPH (' '+ points:Point2D)* ' '+ Adj?;
Adj        <- 'adj' ' '+ DAPOSTROPH adj:Str DAPOSTROPH;
# paths:
#      Adj        <- 'adj' ' '+ DAPOSTROPH adj:(`$root {lines $current} points` Str) DAPOSTROPH;
      Str        <- !DAPOSTROPH <alnum>*;
Point2D    <- `Point2D` 'point' ' '+ x:<digit>+ ' '+ y:<digit>+;
Point3D    <- `Point2D` 'point' ' '+ x:<digit>+ ' '+ y:<digit>+;
void:      DAPOSTROPH    <- '\"' ;
END;}

set aDraw {drawing
  line "Flamingo" point 1 1 point 2 2 point 20 20 point 21 21 point 3 3 point 4 4 point 22 22 point 23 23 adj "Stork"
  line "Stork" point 1 1 point 10 10 adj "Flamingo"}

set builderGen [BuilderGenerator new]
set builderClass [$builderGen bgen $geom]
set diagramBuilder [$builderClass new]

set c [$diagramBuilder parse $aDraw]
? {$c info class} ::Drawing
set lines [$c cget -lines]
? {llength $lines} 2
lassign $lines l1 l2
? {$l1 info class} ::Line
? {$l1 cget -label} "Flamingo"
? {$l1 cget -adj} "Stork"
? {llength [$l1 cget -points]} 8
? {$l2 info class} ::Line
? {$l2 cget -label} "Stork"
? {$l2 cget -adj} "Flamingo"
? {llength [$l2 cget -points]} 2

## TODOS (DONE):
## - fix value passing for quoted, braced values ... too many nesting levels

nx::Class create C {
  :property p1
}

set bGram {OPEG MyPEG (D)
          D <- `C` p1:E;
  leaf:   E <- '\"' <alnum>+ '\"';
END;
}

set b [[$builderGen bgen $bGram] new]

set out [$b parse {"abc"}]

? {$out info class} ::C
? {$out cget -p1} {"abc"}

set b [[$builderGen bgen "
  OPEG MyPEG (D)
          D <- `C` p1:E (<space>+ E)+;
  leaf:   E <- '\"' (<alnum> / '\{' / '\}')+ '\"';
END;
"] new]

set x \{}c

? {string is list $x} 0

set out [$b parse "\"$x\" \"{}xz\""]

? {$out info class} ::C
? {$out cget -p1} "\"$x\""

##
## TODOS: Fix choice propagation
##

nx::Class create Base {
  :property -accessor public p0 {
    :public object method value=get {obj prop in} {
      return [nx::Object create [$obj info class]::$in]
    }
  }
}

nx::Class create XX -superclasses Base {
  :property p1
}

nx::Class create YY -superclasses Base {
  :property p2
}


set pathGr {OPEG MyPEG (D)
       D <- `XX` p1:A / `YY` p2:B; # TODO: top-level expression nesting is not supported (flattening): ((`XX` p1:A / `YY` p2:B))
leaf:  A <-  'A' <digit>+;
leaf:  B <-  'B' <digit>+;
END;
}

# puts [$builderGen print $pathGr]

set d [[$builderGen bgen $pathGr] new]

? {[$d parse {B1}] info class} ::YY
? {[$d parse {A1}] info class} ::XX

## TODO: choice propagation for field paths?

set pathGr {OPEG MyPEG (D)
         D <- '1' / `XX` p1:(`$root p0 $0` A / '0' / `$root p0 $0` C) / '3' / `YY` p2:(`$root p0 $0` B);
  leaf:  A <-  'A' <digit>+;
  leaf:  B <-  'B' <digit>+;
  leaf:  C <-  'C' <digit>+;
  END;}

set d [[$builderGen bgen $pathGr] new]

? {[set b1 [$d parse {B1}]] info class} ::YY
? {[$b1 cget -p2] info name} B1
? {[set a1 [$d parse {A1}]] info class} ::XX
? {[$a1 cget -p1] info name} A1
? {[set c1 [$d parse {C1}]] info class} ::XX
? {[$c1 cget -p1] info name} C1

## TODO Complete ENSO geom example

nx::Class create Drawing {
  :property -accessor public lines:0..n,object,type=::Line {
    :public object method value=get {obj value in:optional} {
      set lines [next [list $obj $value]]
      if {[info exists in]} {
        foreach l $lines {
          if {[$l cget -label] eq $in} {
            return $l
          }
        }
      } else {
        return $lines
      }
    }
  }
}
  
::Line property adj:object,type=::Line

# no paths:
# Adj        <- 'adj' ' '+ DAPOSTROPH adj:Str DAPOSTROPH;
# paths:

set geom2 {
OPEG Drawing (Drawing)
      Drawing    <- `Drawing` 'drawing' (<space>+ lines:Line)+;
      Line       <- `Line` 'line' ' '+ DAPOSTROPH label:Str DAPOSTROPH (' '+ points:Point2D)* ' '+ Adj?;
      Adj        <- 'adj' ' '+ DAPOSTROPH adj:(`$root lines $0` Str) DAPOSTROPH;
      Str        <- !DAPOSTROPH <alnum>*;
      Point2D    <- `Point2D` 'point' ' '+ x:<digit>+ ' '+ y:<digit>+;
void: DAPOSTROPH    <- '\"' ;
END;}

set builderClass [$builderGen bgen $geom2]
set diagramBuilder [$builderClass new]

puts stderr [time {set c2 [$diagramBuilder parse $aDraw]} 1000]; # ~7ms unoptimized

set c2 [$diagramBuilder parse $aDraw]

? {$c2 info class} ::Drawing
set lines [$c2 cget -lines]
? {llength $lines} 2
lassign $lines l1 l2
? {$l1 cget -adj} $l2
? {[$l1 cget -adj] cget -label} [$l2 cget -label]
? {$l2 cget -adj} $l1
? {[$l2 cget -adj] cget -label} [$l1 cget -label]

##
## TODO: boolean assignments based on simple token structures? -->
## predicates needed? IMO, not really, we need to be more pretentious
## on the path/knit expressions, though.
##

nx::Class create Bool {
  :property value:boolean
}

set boolGram {OPEG MyPEG (B)
          B <- `Bool` value:('true' / 'false');
END;
}

set b [[$builderGen bgen $boolGram] new]

set out [$b parse {true}]
? {$out info class} ::Bool
? {$out cget -value} "true"
? {string is boolean [$out cget -value]} 1

set out [$b parse {false}]
? {$out info class} ::Bool
? {string is boolean [$out cget -value]} 1

set boolGram {OPEG MyPEG (B)
          B <- `Bool` value:('true' / 'false');
END;}

set boolGram {OPEG MyPEG (B)
          B <- `Bool` value:(`true` '#' / `false` '##');
END;}

set b [[$builderGen bgen $boolGram] new]

set out [$b parse {##}]
? {$out info class} ::Bool
? {string is boolean [$out cget -value]} 1

set out [$b parse {#}]
? {$out info class} ::Bool
? {$out cget -value} "true"
? {string is boolean [$out cget -value]} 1

## TODO: What to do with non-fields in Sequences?
## -- What does ENSO do: ENSO has field-only sequences?
## ... Should we disallow also?
## ... Is that a case-in-point for mappings? Inject into "mapping"
## operations post-object construction?

nx::Class create BooleanFactory -superclasses ModelFactory {
  :public method "input B" {startIdx endIdx args} {
    if {[info exists :current]} {
      return ${:current}
    } else {
      return [Bool new -value [expr {[lindex $args 0] > [lindex $args 1]}]]
    }
  }
}

set nf [[$builderGen bgen {
  OPEG MyPEG (B)
        # TODO: Maybe allow for writing `Bool` value:(`$0 > $1` Digit ' '+ Digit)?
        B    <- `Bool` value:('true' / 'false') / Digit ' '+ Digit;
        Digit  <- <digit>+;
  END;
} [BooleanFactory new]] new]

set out [$nf parse {true}]
? {$out info class} ::Bool
? {$out cget -value} "true"
set out [$nf parse {20 30}]
? {$out info class} ::Bool
? {$out cget -value} "0"
set out [$nf parse {30 20}]
? {$out info class} ::Bool
? {$out cget -value} "1"

## TODO next: Merge scenario:
## 2D Points, 3D Points, grammar + language model, plus feature model?

nx::Class create Point2D {
  :public method equal {anotherPoint} {
    return [expr {${:x} == [$anotherPoint x get] && ${:y} == [$anotherPoint y get]}]
  }
}

nx::Class create Point3D -superclasses Point2D {
  :property -accessor public z:integer
  :public method equal {anotherPoint} {
    return [expr {[next] && ${:z} == [$anotherPoint z get]}]
  }
}

set geom2 {
OPEG Drawing (Drawing)
      Drawing    <- `Drawing` 'drawing' (<space>+ lines:Line)+;
      Line       <- `Line` 'line' ' '+ DAPOSTROPH label:Str DAPOSTROPH (' '+ points:Point2D)* ' '+ Adj?;
      Adj        <- 'adj' ' '+ DAPOSTROPH adj:(`$root lines $0` Str) DAPOSTROPH;
      Str        <- !DAPOSTROPH <alnum>*;
      Point2D    <- `Point2D` 'point' ' '+ x:<digit>+ ' '+ y:<digit>+;
void: DAPOSTROPH    <- '\"' ;
END;}

## 5) -> Sanity checks at all steps (OPEG validate)?

## 6) pattern matching for testing:

if {0} {
  [Pattern new {Dict {
    a {Bool -value true}
    b {Bool -value false}
  }}] match $out
}

##
## Error detection and reporting; feat. Tiny example from:
##
## Maidl, A. M., Mascarenhas, F., & Ierusalimschy,
## R. (2013). Exception Handling for Error Reporting in Parsing
## Expression Grammars. In: Proc. 17th Brazilian Symposium
## Programming Languages (SBLP 2013) (pp. 1--15). Springer.
##

set fh [open [file join [file dirname [info script]] "tiny.peg"] r]
set tiny [read $fh]
catch {close $fh}

## minimal FFP support

nx::Class create FFP {
  :property -accessor public {ffp:substdefault {[list]}}
  
  # FFP: available on [complete]
  :public method complete {} {
    # puts FFP=${:ffp}
    next
  }

  # FFP: actual FFP recording in the spirit of "i_error_pop_merge",
  # without popping, naturally. At this point, "myerror", if
  # available, carries a previously popped error-stack element.
  :method updateFFP {} {
    if {![info exists :ffp] || ![llength ${:ffp}]} {
      set :ffp ${:myerror}; return
    }
    
    if {![llength ${:myerror}]} {
      return
    }
    
    lassign ${:myerror} currentErrPos currentErrMsg
    lassign ${:ffp} prevFfpPos prevFfpMsg
    
    if {$prevFfpPos > $currentErrPos} { return; }
    if {$currentErrPos > $prevFfpPos} {
      set :ffp ${:myerror}
    }
    # Equal locations, merge the message lists
    set :ffp [list $currentErrPos [lsort -uniq [list {*}$prevFfpMsg {*}$currentErrMsg]]]
  }

  # Instrumentation (1): end-of-choice
  
  foreach m {si:void_state_merge si:value_state_merge} {
    :method $m {} {
      :updateFFP
      next      
    }
  }
  
  # Instrumentation (2): mid-of-choice
  foreach m {si:valuevoid_branch si:valuevalue_branch si:voidvoid_branch si:voidvalue_branch} {
    :method $m {} {
      try {set r [next]} on return {} {
        # caught a backtracking return, update ffp
        :updateFFP 
        return -code return
      }
      return $r
    }
  }
}


set builderGen [BuilderGenerator new]
set builderClass [$builderGen bgen $tiny]
set tinyParser [$builderClass new]


set p {n := 1;}
? {lassign [$tinyParser parset $p] _ start end; set end} [expr {[string length $p]-1}]; # fully consumed?

set tinyProg {
  n := 5;
  f := 1;
  repeat
    f := f * n;
    n := n - 1
  until n < 1;
  write f;
}

$builderClass mixins add FFP

try {
  lassign [$tinyParser parset $tinyProg] root start end
} on error {e} {
  # with EOI in Tiny grammar
  lassign $e _ loc
  ? {set loc} 23; # points to repeat
  ? {lindex [$tinyParser ffp get] 0} 63;  # points to begin of u(ntil).
} on ok {r} {
  # TODO: complete, cases without EOI
  # prefix
  ? {string range $tinyProg $start $end} $tinyProg
  # suffix
  ? {string range $tinyProg [expr {$end+1}] [string length $tinyProg]} ""
} finally {
  $tinyParser destroy
}

$builderClass mixins delete FFP

#
# Minimal combination support for NX/PARAM parsers (parser combinators)
#


pt::rde::nx public method cswitch {parentParser {instr MAIN}} {

  # puts "SWITCH: $parentParser -($instr)-> [self]"
  # puts STACKPARENT=[$parentParser eval "\${:mystackast} size"]
  :reset {}
  ## dump current parsing state in sub-parser
  set myloc [$parentParser eval {:location}]

  incr myloc
  set mtoken [$parentParser eval {set :mytoken}]

  if {$myloc >= [string length $mtoken]} {
    $parentParser eval {set :myok 0}
    # set myerror [list $myloc [list [list t $tok]]]
    return
  }

  set dat [string range $mtoken $myloc end]

  :data $dat
  #puts myloc=$myloc,dat=$dat


  # TODO: needed?
  # $parentParser eval "\${:mystackloc} push ${:myloc}"
  
  : $instr

  $parentParser eval [list set :myok ${:myok}]
  
  if {${:myok}} {
    set subAst [:complete]
    lassign $subAst nt start end
    # puts subAst=$myloc,${:myloc},$end,$subAst
    # TODO: in nested sub ASTs, all range markers must be bumped!
    set subAst [list $nt $myloc [expr {$myloc + $end}]]
    $parentParser eval "\${:mystackast} push [list $subAst]"
    $parentParser eval [list set :myloc [expr {$myloc + $end}]]
  } else {
    #
    # TODO: fix loc on error (in the error report and for the pparser)
    #
    set parentErr [$parentParser eval {set :myerror}]
    lassign $parentErr oldPos oldMsg
    lassign ${:myerror} newPos newMsg
    set newLoc [expr {$myloc + $newPos}]
    
    if {$oldPos > $newLoc} {
      return
    }
    if {$newLoc > $oldPos} {
      set msg $newMsg
    } else {
      set msg [list {*}$oldMsg {*}$newMsg]
    }
    
    $parentParser eval [list set :myerror [list $newLoc $msg]]
    $parentParser eval [list set :myloc $newLoc]
  }

}

set digit [[pt::rde::nx pgen {PEG DIGIT (digit) digit <- [0-9]; END;}] new]
set letter [[pt::rde::nx pgen {PEG LETTER (letter) letter <- [a-z] / [A-Z]; END;}] new]

? {$digit parset {1}} {digit 0 0}
? {$letter parset {a}} {letter 0 0}

set identifier [[pt::rde::nx pgen {PEG ID (id) digit <- .; letter <- .; id <- letter (letter / digit)*; END;}] new]



? {$identifier parset {1}} {id 0 0 {letter 0 0}}

$identifier object forward sym_letter $letter cswitch %self %method
$identifier object forward sym_digit $digit cswitch %self %method

# debug on pt/rdengine
? {$identifier parset {a}} {id 0 0 {letter 0 0}}
? {$identifier parset {1}} {pt::rde 0 {{cl abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}}}
? {$identifier parset {abc}} {id 0 2 {letter 0 0} {letter 1 1} {letter 2 2}}
? {$identifier parset {a1}} {id 0 1 {letter 0 0} {digit 1 1}}
# debug off pt/rdengine

set dletters [[pt::rde::nx pgen {PEG LETTER (dletters) dletters <- [a-z][a-z] / [A-Z][A-Z]; END;}] new]
set identifier2 [[pt::rde::nx pgen {PEG ID2 (id) digit <- .; dletters <- .; id <- dletters (dletters / digit)*; END;}] new]
$identifier2 object forward sym_dletters $dletters cswitch %self %method
$identifier2 object forward sym_digit $digit cswitch %self %method
? {$identifier2 parset {aabb1}} {id 0 4 {dletters 0 1} {dletters 2 3} {digit 4 4}}
? {$identifier2 parset {aab11}} {id 0 1 {dletters 0 1}}; # partial parse
$identifier2 object mixins add FFP
? {$identifier2 parset {aab11}} {id 0 1 {dletters 0 1}}; # partial parse + FFP
$identifier2 object mixins delete FFP

## pt_peg_to_tclparam.tcl
proc ::pt::peg::to::tclparam::Op::n {modes symbol} {
    # symbol mode determines AST generation
    # void       => non-generative,
    # leaf/value => generative.

    Asm::Start
    Asm::ReTerminal n $symbol

    # TODO: limit to Parser instances, allow for late binding (cyclic
    # relationships in the nested parser structure).
    if {[::nsf::is object $symbol]} {
      Asm::GenAST [list gen 1]; # TODO: get this from parser obj
      Asm::Direct {
        # TODO: collect the needed parent infos here, or use a
        # redirector on the parent.
        Asm::Tcl $symbol cswitch \[self\]
      }
    } else {
      if {![dict exists $modes $symbol]} {
        # Incomplete grammar. The symbol has no definition.
        Asm::Direct {
          Asm::Ins i_status_fail "; # Undefined symbol '$symbol'"
        }
      } else {
        Asm::GenAST [list gen [expr { [dict get $modes $symbol] ne "void" }]]
        Asm::Direct {
          Asm::Self sym_$symbol
        }
      }
    }
    Asm::Done
}

# set letter [[pt::rde::nx pgen {[a-z] / [A-Z]}] new]


[pt::rde::nx pgen {PEG DIGIT (digit) digit <- [0-9]; END;}] create ::digit
[pt::rde::nx pgen {PEG LETTER (letter) letter <- [a-z] / [A-Z]; END;}] create ::letter


set identifier [[[BuilderGenerator new] bgen "OPEG ID (id) id <- ::letter (::letter / ::digit)*; END;"] new]

? {$identifier parset {a}} {id 0 0 {letter 0 0}}
? {$identifier parset {1}} {pt::rde 0 {{cl abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}}}
? {$identifier parset {abc}} {id 0 2 {letter 0 0} {letter 1 1} {letter 2 2}}
? {$identifier parset {a1}} {id 0 1 {letter 0 0} {digit 1 1}}

## TODOS:
##
## 1) Parser-based builder interface (parser combination)
##
## 2) Implement parser-as-symbol in the intermediate (canonical) PEG
## representation: method-call frontend to intermediate PEG.

## ser=pt::grammar::peg {rules {id {is {x {n ::letter} {* {/ {n ::letter} {n ::digit}}}} mode value}} start {n id}}

pt::rde::nx public method asPeg {} {
  if {[info exists :myPeg]} {
    return ${:myPeg}
  } else {
    return [list n [self]]
  }
}

pt::rde::nx public method fromPeg {ser} {

  pt::tclparam::configuration::nx def _ _ _  {pt::peg::to::tclparam configure}
  
  ## strip down to just the core script fragment
  pt::peg::to::tclparam configure -template {@code@}
  
  set body [pt::peg::to::tclparam convert $ser]
  
  return [pt::rde::nx ]
}


pt::rde::nx public method {,} {args} {
  set :myPeg [list x {*}[lmap p [list [self] {*}$args] {$p asPeg}]]
  return [self]
}

pt::rde::nx public method / {args} {
  set :myPeg [list / {*}[lmap p [list [self] {*}$args] {$p asPeg}]]
  return [self]
}

pt::rde::nx public method * {} {
  return [list * [:asPeg]]
}



pt::rde::nx public method -> {args} {
  
}


? {[::letter , ::letter ::letter] asPeg} {x {n ::letter} {n ::letter} {n ::letter}}

? {[::letter / ::digit] asPeg} {/ {n ::letter} {n ::digit}}

? {[::letter *] asPeg} {* {n ::letter}}

? {[[::letter / ::digit] *] asPeg} {* {/ {n ::letter} {n ::digit}}}

? {[[::letter / ::digit] -> identifier] info has type "pt::rde::nx"} 1

##
## 3) fix debug support in NX engine class (use apply wrapper to set
## the namespace context correctly)
##
## 4) minimize pgen/bgen interface (default to some HEADER etc.)
##
## 5) fit object generators into builder interface
##
## 6) introduce an operator other than n? to generalize the injection
## and to avoid interactions with other PEG extension modifying the
## syntax of identifiers/symbols?
##

exit

## letter (letter / digit letter / digit )*
set identifier [$letter , {{{{$letter : p1} / {$digit $letter} / $digit} *}}]
set identifier [$letter , [[$letter / [$digit , $letter] / $digit] *] , $letter]
set identifier [$letter , [[$letter / [$digit , $letter] / $digit] *] , {[0-9]+ / 'aaa'} : p2]

$letter , 
set identifier [then $letter then $letter then choice $letter $digit]
set identifier [$letter then $letter choice ]

# package req nx::serializer; this stumbles over the TclOO alien :(
# puts identifier=[$identifier serialize]


	    # ## clone all methods
	    # foreach m [info class methods ${:prototype} -private] {
	    #     lassign [info class definition ${:prototype} $m] params body
		
	    #     if {1} {
	    #         :method $m $params [string map [list @body@ $body @vars@ $vars] {
	    #     	@vars@
	    #     	@body@
	    #         }]
	    #     } else {
		
	    #     set methodBody [string map [list @body@ $body @vars@ $vars @params@ $params] {
	    #         try {
	    #     	apply [list {@params@} {
	    #     	    @vars@
	    #     	    @body@
	    #     	} [self]] {*}${args}
	    #         } on return {} {
	    #     	return -code return
	    #         }
	    #     }]
	    #     :method $m {args} $methodBody
	    # }
	    # }  
}


#
# Local variables:
#    mode: tcl
#    tcl-indent-level: 2
#    indent-tabs-mode: nil
# End:
#
